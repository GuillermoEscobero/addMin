addv_2 reg1 reg2 reg3 reg4 {
  co=011000,
  nwords=1,
  reg1=reg(25,21), #R0
  reg2=reg(20,16), #V0
  reg3=reg(15,11), #V1
  reg4=reg(10,6), #number
  {
    #To begin, we save the registers reg1, reg2 and reg3 into the stack to preserve the values once the microprogramhas ended
    #paso1: restar al sp 4
    (SELA=11101, MR=1, MA=0, MB=10, SELCOP=1011, MC=1, T6, SELC=11101, LC=1),

    #paso2: meter en la direccion de memoria existente en sp el valor que quiero preservar
    (SELA=11101, MR=1, T9, C0),
    (SELB=10101, MR=0, T10, M1=0, C1),
    (BW=11, TA=1, TD=1, W=1),

    (SELA=11101, MR=1, MA=0, MB=10, SELCOP=1011, MC=1, T6, SELC=11101, LC=1),

    (SELA=11101, MR=1, T9, C0),
    (SELB=10000, MR=0, T10, M1=0, C1),
    (BW=11, TA=1, TD=1, W=1),

    (SELA=11101, MR=1, MA=0, MB=10, SELCOP=1011, MC=1, T6, SELC=11101, LC=1),

    (SELA=11101, MR=1, T9, C0),
    (SELB=01011, MR=0, T10, M1=0, C1),
    (BW=11, TA=1, TD=1, W=1),

    #We start the procedure comparing the number of elements, if it is negative, go to error1 label
    (T8=1, C5=1),
    (SELB=00000, MR=1, T10=1, C5),
    (SELA=00110, MR=0, MA=0, MB=1, SELCOP=1011, MC=1, SELP=11, M7=1, C7=1),
    (A0=0, B=0, C=0111, MADDR=error1),

    (SELA=0000, MR=1, T9, C4),

    #compare the number in RT1 (where the counter is set) to the number of elements in reg4 (given by the user)
    begin1:
    (SELB=00110, MR=0, MB=0, MA=1, SELCOP=1011, MC=1, SELP=11, M7=1, C7=1),
    (A0=0, B=0, C=0110, MADDR=restore1),

    #start loading the first word in the reg2
    (MR=0, SELA=10000, T9=1, C0),
    (TA=1, R=1, BW=11, M1=1, C1=1),

    #we start retrieving the second word, in reg3
    (MR=0, SELB=01011, T10=1, C0),

    #store the first word into RT2
    (T1=1, C5, TA=1, R=1, BW=11, M1=1, C1=1),

    #move the value of RT1 into RT3
    (SELB=00000, MR=1, SELCOP=1010, MC=1, MA=1, MB=0, C6),

    #store the second word into RT1
    (T1=1, C4),

    #We introduce the numbers in the ALU, operate them and then save the sum into RT2
    (MA=1, MB=1, SELCOP=1010, MC=1, T6, C5),

    #Move the value of RT3 to RT1 (counter)
    (T7, C4),

    #we get the address of R0 (reg1) and store in it the result of the sum (RT2)
    (MR=0, SELA=10101,  T9=1, C0),
    (T5=1, M1=0, C1=1),
    (BW=11, TA=1, TD=1, W=1),

    #increment the memory address of reg1, reg2 and reg3
    (MC=1, MR=0, SELA=10101, MA=0, MB=10, SELCOP=1010, T6, SELC=10101, LC=1),
    (MC=1, MR=0, SELA=10000, MA=0, MB=10, SELCOP=1010, T6, SELC=10000, LC=1),
    (MC=1, MR=0, SELA=01011, MA=0, MB=10, SELCOP=1010, T6, SELC=01011, LC=1),

    #increment the counter by 1
    (MA=1, MB=11, SELCOP=1010, MC=1, T6, C4),

    #go to the label begin1 and start again the process
    (A0=0, B=1, C=0, MADDR=begin1),

    #label reached when the size of the arrays given in reg4 is negative, it stores a -1 in reg1 and goes to label end1
    error1:
    (MC=1, RA=0, MA=0, MB=11, SELCOP=1011, T6, SELC=10101, LC=1),
    (A0=0, B=1, C=0, MADDR=restore1),

    restore1:
    #paso 1 sacar ek valor
    (SELA=11101, MR=1, T9, C0),
    (TA=1, R=1, BW=11, M1=1, C1),
    (SELC=01011, MR=0, T1, LC),

    #paso 2 sumar 4 al sp
    (SELA=11101, MR=1, MA=0, MB=10, SELCOP=1010, MC=1, T6, SELC=11101, LC=1),

    (SELA=11101, MR=1, T9, C0),
    (TA=1, R=1, BW=11, M1=1, C1),
    (SELC=10000, MR=0, T1, LC),

    (SELA=11101, MR=1, MA=0, MB=10, SELCOP=1010, MC=1, T6, SELC=11101, LC=1),

    (SELA=11101, MR=1, T9, C0),
    (TA=1, R=1, BW=11, M1=1, C1),
    (SELC=10101, MR=0, T1, LC),

    (SELA=11101, MR=1, MA=0, MB=10, SELCOP=1010, MC=1, T6, SELC=11101, LC=1),


    (A0=1, B=1, C=0)

  }
}

seqv_2 reg1 reg2 reg3 reg4 {
  co=011001,
  nwords=1,
  reg1=reg(25,21), #R0
  reg2=reg(20,16), #V0
  reg3=reg(15,11), #V1
  reg4=reg(10,6), #number
  {
    #To begin, we save the registers reg1, reg2 and reg3 into the stack to preserve the values once the microprogramhas ended
    #paso1: restar al sp 4
    (SELA=11101, MR=1, MA=0, MB=10, SELCOP=1011, MC=1, T6, SELC=11101, LC=1),

    #paso2: meter en la direccion de memoria existente en sp el valor que quiero preservar
    (SELA=11101, MR=1, T9, C0),
    (SELB=10101, MR=0, T10, M1=0, C1),
    (BW=11, TA=1, TD=1, W=1),

    (SELA=11101, MR=1, MA=0, MB=10, SELCOP=1011, MC=1, T6, SELC=11101, LC=1),

    (SELA=11101, MR=1, T9, C0),
    (SELB=10000, MR=0, T10, M1=0, C1),
    (BW=11, TA=1, TD=1, W=1),

    (SELA=11101, MR=1, MA=0, MB=10, SELCOP=1011, MC=1, T6, SELC=11101, LC=1),

    (SELA=11101, MR=1, T9, C0),
    (SELB=01011, MR=0, T10, M1=0, C1),
    (BW=11, TA=1, TD=1, W=1),

    (SELA=0000, MR=1, T9, C4),

    #We start the procedure comparing the number of elements, if it is negative, go to error1 label
    (T8=1, C5=1),
    (SELB=00000, MR=1, T10=1, C5),
    (SELA=00110, MR=0, MA=0, MB=1, SELCOP=1011, MC=1, SELP=11, M7=1, C7=1),
    (A0=0, B=0, C=0111, MADDR=error2),

    #compare the number in RT1 (where the counter is set) to the number of elements in reg4 (given by the user)
    begin2:
    (SELB=00110, MR=0, MB=0, MA=1, SELCOP=1011, MC=1, SELP=11, M7=1, C7=1),
    (A0=0, B=0, C=0110, MADDR=end2),

    #start loading the first word in the reg2
    (MR=0, SELA=10000, T9=1, C0),
    (TA=1, R=1, BW=11, M1=1, C1=1),

    #we start retrieving the second word, in reg3
    (MR=0, SELB=01011, T10=1, C0),

    #store the first word into RT2
    (T1=1, C5, TA=1, R=1, BW=11, M1=1, C1=1),

    #move the value of RT1 into RT3
    (SELB=00000, MR=1, SELCOP=1010, MC=1, MA=1, MB=0, C6),

    #store the second word into RT1
    (T1=1, C4),

    #we introduce the values in the ALU, we operate using the XOR, then it checks if it is 0 (if it is different it goes to label different)
    (MA=1, MB=1, SELCOP=0100, MC=1, SELP=11, M7, C7),
    (A0=0, B=1, C=0110, MADDR=different),

    #Move the value of RT3 to RT1 (counter)
    (T7, C4),

    #increment the memory address of reg1, reg2 and reg3
    (MC=1, MR=0, SELA=10101, MA=0, MB=10, SELCOP=1010, T6, SELC=10101, LC=1),
    (MC=1, MR=0, SELA=10000, MA=0, MB=10, SELCOP=1010, T6, SELC=10000, LC=1),
    (MC=1, MR=0, SELA=01011, MA=0, MB=10, SELCOP=1010, T6, SELC=01011, LC=1),

    #increment the counter by 1
    (MA=1, MB=11, SELCOP=1010, MC=1, T6, C4),

    #go to the label begin2 and start again the process
    (A0=0, B=1, C=0, MADDR=begin2),

    #label reached when the size of the arrays given in reg4 is negative, it stores a -1 in reg1 and goes to label end2
    error2:
    (MC=1, RA=0, MA=0, MB=11, SELCOP=1011, T6, SELC=10101, LC=1),
    (A0=0, B=1, C=0, MADDR=end2),

    #if during the process a different number is detected, this label is reached, setting reg1 to 0 and going to fetch to end the microprogram
    different:
    (SELA=00000, MR=1, T9, C5),
    (SELC=10101, MR=0, T5, LC),
    (A0=0, B=1, C=0, MADDR=restore2),

    #sets reg1 to 1 (since all the elements are equal) and sets A0, B and C to jump to fetch to end the microprogram
    end2:
    (SELA=00000, MR=1, MA=0, MB=11, SELCOP=1010, MC=1, C6),
    (SELC=10101, MR=0, T7, LC),
    (A0=0, B=1, C=0, MADDR=restore2),

    restore2:
    #paso 1 sacar ek valor
    (SELA=11101, MR=1, T9, C0),
    (TA=1, R=1, BW=11, M1=1, C1),
    (SELC=01011, MR=0, T1, LC),

    #paso 2 sumar 4 al sp
    (SELA=11101, MR=1, MA=0, MB=10, SELCOP=1010, MC=1, T6, SELC=11101, LC=1),

    (SELA=11101, MR=1, T9, C0),
    (TA=1, R=1, BW=11, M1=1, C1),
    (SELC=10000, MR=0, T1, LC),

    (SELA=11101, MR=1, MA=0, MB=10, SELCOP=1010, MC=1, T6, SELC=11101, LC=1),

    (SELA=11101, MR=1, T9, C0),
    (TA=1, R=1, BW=11, M1=1, C1),
    (SELC=10101, MR=0, T1, LC),

    (SELA=11101, MR=1, MA=0, MB=10, SELCOP=1010, MC=1, T6, SELC=11101, LC=1),


    (A0=1, B=1, C=0)
  }
}
